Scenario: Data model doc has all required entities
EXISTS
Entities check (Tenant, User, Team, Robot, ChatGroup, Message, WorkspaceFile, ApiKey):
    ChatGroup ||--o{ ChatGroupMember : has
    ChatGroup ||--o{ Message : contains
    ChatGroupMember }o--|| Robot : is
    ChatGroupMember }o--|| User : is
    Robot ||--o{ Message : sends
    Team ||--o{ ChatGroup : has
    Team ||--o{ TeamMember : contains
    TeamMember }o--|| Robot : is
    TeamMember }o--|| User : is
    Tenant ||--o{ ApiKey : has
    Tenant ||--o{ Robot : owns
    Tenant ||--o{ Team : owns
    Tenant ||--o{ TenantUser : has
    TenantUser }o--|| User : references
    User ||--o{ ApiKey : owns
    User ||--o{ Message : sends
    User ||--o{ TenantUser : belongs_to
    WorkspaceFile }o--|| ChatGroup : scoped_to
    WorkspaceFile }o--|| Team : scoped_to
    WorkspaceFile }o--|| Tenant : scoped_to
    WorkspaceFile }o--|| User : uploaded_by
  apiKeys   ApiKey[]
  chatGroup    ChatGroup? @relation(fields: [scopeId], references: [id], map: "scope_chatgroup")
  files       WorkspaceFile[]
  files     WorkspaceFile[]
  group       ChatGroup @relation(fields: [chatGroupId], references: [id])
  groups    ChatGroup[]
  members     ChatGroupMember[]
  members   TeamMember[]
  messages    Message[]
  messages  Message[]
  robots    Robot[]
  team         Team?     @relation(fields: [scopeId], references: [id], map: "scope_team")
  team        Team     @relation(fields: [teamId], references: [id])
  team       Team     @relation(fields: [teamId], references: [id])
  teams     Team[]
  tenant         Tenant   @relation(fields: [tenantId], references: [id])
  tenant       Tenant?   @relation(fields: [scopeId], references: [id], map: "scope_tenant")
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  tenant    Tenant?  @relation(fields: [tenantId], references: [id])
  tenants   TenantUser[]
  user      User     @relation(fields: [userId], references: [id])
  user      User?    @relation(fields: [userId], references: [id])
  users     TenantUser[]
## Multi-Tenant Isolation Strategy
### Organizations & Teams
### Robots & Intelligence
> The data model prioritizes strong consistency and strict multi-tenant isolation. Every organizational unit belongs to a Tenant. Access control is enforced at the database level using a shared-schema, row-filtering approach.
Access is managed by the `TenantUser` relation. When a user logs in, they select a tenant context. The platform verifies their role (owner, admin, or user) before authorizing operations. Robots are strictly bound to a single tenant. They can only access resources within chatgroups where they are members.
model ApiKey {
model ChatGroup {
model ChatGroupMember {
model Message {
model Robot {
model Team {
model TeamMember {
model Tenant {
model TenantUser {
model User {
model WorkspaceFile {
Diagram check:
2
Prisma model check:
13
